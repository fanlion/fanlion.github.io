<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李繁的个人博客</title>
  
  <subtitle>也许理想可以更远大点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://fanlion.cc/"/>
  <updated>2019-03-04T15:36:24.142Z</updated>
  <id>http://fanlion.cc/</id>
  
  <author>
    <name>fan.lion</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The JavaScript Event Loop 译文</title>
    <link href="http://fanlion.cc/2019/03/04/The-JavaScript-Event-Loop-%E8%AF%91%E6%96%87/"/>
    <id>http://fanlion.cc/2019/03/04/The-JavaScript-Event-Loop-译文/</id>
    <published>2019-03-04T09:44:53.000Z</published>
    <updated>2019-03-04T15:36:24.142Z</updated>
    
    <content type="html"><![CDATA[<p>文本是<a href="https://flaviocopes.com/javascript-event-loop/" target="_blank" rel="noopener">The JavaScript Event Loop</a>的译文,以下为译文正文部分。</p><hr><h1 id="JavaScript-事件循环"><a href="#JavaScript-事件循环" class="headerlink" title="JavaScript 事件循环"></a>JavaScript 事件循环</h1><p>事件循环是了解JavaScript的最重要方面之一，本文通过简单的术语去解释它。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>事件循环是了解JavaScript的最重要方面之一，本文通过简单的术语去解释它。</p><blockquote><p>我已经用JavaScript编程好几年了，但我从来没完整的理解它是如何运作的。不去知道这些概念的细节也是完全没问题的，但是通常，这对于我们知道是它如何运作的十分帮助，你也许只是对它有一点点好奇心。</p></blockquote><a id="more"></a><p>这篇文章的目标是解释JavaScript是如何在一个单线程中工作，以及它是如何处理异步函数的内部细节。</p><p>你的JavaScript代码运行在一个单线程里。这意味着同一时刻只能发生一件事。</p><p>这个限制通常也十分有用，因为它可以简化很多，让你的程序不用担心并发的问题。</p><p>你只需要将注意力放在如何去写你的代码并避免任何可能会阻塞这个线程的事情，例如同步的网络调用或者无限循环。</p><p>通常，大多数浏览器每个浏览器tab都存在一个事件循环，让每个进程隔离，避免一个存在无限循环或者大量处理任务的web页面阻塞了你的整个浏览器。</p><p>例如，环境管理多个并发的事件循环，以处理API调用。同样，<a href="https://flaviocopes.com/web-workers/" target="_blank" rel="noopener">Web Workers</a>运行在它们自己的事件循环里。</p><p>你主要需要关心的是你的代码将运行在一个单事件循环里，然后在写代码的时候记在脑海中去避免阻塞它。</p><h2 id="阻塞事件循环"><a href="#阻塞事件循环" class="headerlink" title="阻塞事件循环"></a>阻塞事件循环</h2><p>任何需要很长时间才能将控制权返回给事件循环的JavaScript代码都会阻止页面中任何JavaScript代码的执行，甚至阻塞UI线程，导致用户不能点击、滚动页面等。</p><p>几乎JavaScript中的所有的<code>I/O</code>原语都是非阻塞的。网络请求、Node.js文件系统操作等。被阻塞是个例外，这也是为什么JavaScript基于如此多的回调，以及最近的<code>Promise</code>和<code>async/await</code>。</p><h2 id="调用堆栈"><a href="#调用堆栈" class="headerlink" title="调用堆栈"></a>调用堆栈</h2><p>调用堆栈是一个<code>LIFO</code>队列（后进、先出）</p><p>事件循环不断的检查调用堆栈去查看是否还存在任何需要被执行的函数。</p><p>在执行此操作时，它会将它找到的任何函数调用添加到调用堆栈并按顺序执行每个调用</p><p>你了解调试器或浏览器控制台中你可能熟悉的错误堆栈跟踪吗？浏览器在调用堆栈中查找函数名称以通知你哪个函数发起当前调用：</p><p><img src="/2019/03/04/The-JavaScript-Event-Loop-译文/exception-call-stack.png" alt="exception-call-stack"></p><h2 id="一个简单的事件循环说明"><a href="#一个简单的事件循环说明" class="headerlink" title="一个简单的事件循环说明"></a>一个简单的事件循环说明</h2><p>让我们选择一个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  bar()</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>上面代码打印</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">baz</span><br></pre></td></tr></table></figure><p>正如我们所预期一样。</p><p>当代码开始执行，首先<code>foo()</code>被调用。在<code>foo()</code>内部我们首先调用<code>bar()</code>，然后我们调用<code>barz()</code>。</p><p>在这个时候，调用栈看起来像这样：</p><p><img src="/2019/03/04/The-JavaScript-Event-Loop-译文/call-stack-first-example.png" alt="call-stack-first-example"></p><p>事件循环的每次迭代都会查看调用栈中是否存内容，如果存在则执行它：</p><p><img src="/2019/03/04/The-JavaScript-Event-Loop-译文/execution-order-first-example.png" alt="hexecution-order-first-example"></p><p>直到调用栈为空。</p><h2 id="队列中函数执行"><a href="#队列中函数执行" class="headerlink" title="队列中函数执行"></a>队列中函数执行</h2><p>上面的例子看起来很寻常，没有什么特殊之处：JavaScript找到一些东西去执行，按顺序执行。</p><p>让我们看一下如何延迟一个函数直到堆栈清空了再执行。</p><p><code>setTimeout(() =&gt; {}), 0)</code>的用法是去调用一个函数，但是，一旦代码中的其他函数都执行了才会去执行它。</p><p>举个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  setTimeout(bar, <span class="number">0</span>)</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>下面是它的代码打印，也许出乎意料：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">baz</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>当代码运行，首先<code>foo()</code>被调用。在<code>foo()</code>内部我们先调用<code>setTimeout()</code>，通过把<code>bar</code>作为参数传递，并传递<code>0</code>作为定时器，我们希望尽可能快的立即执行它，然后再去执行<code>baz()</code>。</p><p>在这个时候调用栈看起来像这样：</p><p><img src="/2019/03/04/The-JavaScript-Event-Loop-译文/call-stack-second-example.png" alt="call-stack-second-example"></p><p>这是我们程序中所有函数的执行顺序：</p><p><img src="/2019/03/04/The-JavaScript-Event-Loop-译文/execution-order-second-example.png" alt="execution-order-second-example"></p><p>为什么会这样？</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>当<code>setTimeout()</code>被调用，浏览器或者Node.js启动定时器。一旦时间到了，在这个例子中是立刻，因为我们把<code>0</code>设置为了超时时长，这个回调函数被放入了消息队列。</p><p>消息队列也是像用户所产生的点击、键盘事件或者是<code>fetch</code>响应在你的代码有机会响应它们之前所排队的地方，或者是像<code>onLoad</code>这种<code>DOM</code>事件。</p><p>事件循环优先考虑调用栈，它会首先处理在调用栈中找到的内容，一旦调用栈为空，它会去拾取消息队列中的内容。</p><p>我们不用去等待函数（像<code>setTimeout</code>、<code>fetch</code>或者是其他的东西完）成它们自己的工作，因为它们是浏览器提供的，它们存货在自己的线程里。例如，你设置<code>setTimeout</code>的超时时间到2秒，你不用等待2秒，这个等待发生在其他地方。</p><h2 id="ES6作业队列"><a href="#ES6作业队列" class="headerlink" title="ES6作业队列"></a>ES6作业队列</h2><p><code>ECMAScript 2015</code>引入了<code>作业队列</code>的概念，它被<code>Promises</code>使用（ES6/ES2015引入的）。 这是一种尽快执行异步函数结果的方法，而不是放在调用栈的末尾。</p><p>我发现把它比喻为在游乐园里的过山车再恰当不过了：消息队列把你反正队列的后面，在所有其他人之后，在那里你不得不等到轮到你，而作业队列是快速通过的票，让你完成上一次乘坐后立马再次乘坐。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'bar'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> baz = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'baz'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>)</span><br><span class="line">  setTimeout(bar, <span class="number">0</span>)</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">    resolve(<span class="string">'should be right after baz, before bar'</span>)</span><br><span class="line">  ).then(<span class="function"><span class="params">resolve</span> =&gt;</span> <span class="built_in">console</span>.log(resolve))</span><br><span class="line">  baz()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>它的输出</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">baz</span><br><span class="line">should be right after baz, before bar</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p>这是<code>Promises</code>（以及 async/await, 它们是构建与<code>promises</code>之上的）和普通的老式异步函数（通过<code>setTimeout()</code>或者其他的平台<code>APIs</code>）之间的巨大差异。</p><hr><p>END</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本是&lt;a href=&quot;https://flaviocopes.com/javascript-event-loop/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;The JavaScript Event Loop&lt;/a&gt;的译文,以下为译文正文部分。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;JavaScript-事件循环&quot;&gt;&lt;a href=&quot;#JavaScript-事件循环&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 事件循环&quot;&gt;&lt;/a&gt;JavaScript 事件循环&lt;/h1&gt;&lt;p&gt;事件循环是了解JavaScript的最重要方面之一，本文通过简单的术语去解释它。&lt;/p&gt;
&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;事件循环是了解JavaScript的最重要方面之一，本文通过简单的术语去解释它。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我已经用JavaScript编程好几年了，但我从来没完整的理解它是如何运作的。不去知道这些概念的细节也是完全没问题的，但是通常，这对于我们知道是它如何运作的十分帮助，你也许只是对它有一点点好奇心。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://fanlion.cc/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JavaScript" scheme="http://fanlion.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>通过defer和async高效加载JavaScript</title>
    <link href="http://fanlion.cc/2019/03/04/%E9%80%9A%E8%BF%87defer%E5%92%8Casync%E9%AB%98%E6%95%88%E5%8A%A0%E8%BD%BDJavaScript/"/>
    <id>http://fanlion.cc/2019/03/04/通过defer和async高效加载JavaScript/</id>
    <published>2019-03-04T06:21:47.000Z</published>
    <updated>2019-03-04T13:07:33.137Z</updated>
    
    <content type="html"><![CDATA[<p>文本是<a href="https://flaviocopes.com/javascript-async-defer/" target="_blank" rel="noopener">Efficiently load JavaScript with defer and async</a>的译文,以下为译文正文部分。</p><hr><h1 id="通过defer和async高效加载JavaScript"><a href="#通过defer和async高效加载JavaScript" class="headerlink" title="通过defer和async高效加载JavaScript"></a>通过defer和async高效加载JavaScript</h1><p>当在一个HTML页面上加载一个script时，你需要小心应对以免引起页面的加载性能问题。</p><p>一个script传统上通过下面这种方式引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"script.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>当HTML解析器发现这行代码时，一个请求将被准备好去获取这个script并执行这个script.</p><a id="more"></a><p>一旦这个过程完成，解析过程将被恢复，剩余的HTML才能完成分析。</p><p>正如你可以想象得到的，这个操作会对这个页面的加载时间产生巨大的影响。</p><p>如果这个script的加载花费了比预期时间还要稍微长一点的时间，例如网络有点慢或者你在手机设备上并且网络连接有点糟糕，访客很有可能在script被加载和执行之前看到一个空白页面。</p><h2 id="脚本位置问题"><a href="#脚本位置问题" class="headerlink" title="脚本位置问题"></a>脚本位置问题</h2><p>当你第一次学习HTML的时候，你被告知script 标签需要放置在<code>&lt;head&gt;</code>标签里：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"script.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正如我之前所说的，当解析器发现这行时，解析器会去获取这个script并执行这行它。然后，在获取到script并执行script后，解析器才会接着去解析body里的内容。</p><p>这是糟糕的，因为这会引进一些延时。对于这个问题，一个十分通用的解决方案是把<code>script</code>标签放在页面的底部，<code>在&lt;/body&gt;</code>这个闭合标签之前。</p><p>通过上面的方法，script标签将会在所有页面完成解析和加载后再完成加载和执行。相对于把<code>script</code>放在<code>head</code>中是个巨大的提升。</p><p>如果你需要支持那些不支持<code>HTML</code>最近特性标签：<code>async</code>和<code>defer</code>的老式浏览器，上面的方法已经是你所能做的事情里面做得最好的了。</p><h2 id="Async-和-Defer"><a href="#Async-和-Defer" class="headerlink" title="Async 和 Defer"></a>Async 和 Defer</h2><p><code>async</code>和<code>defer</code>都是<code>boolean</code>类型的属性，它们的用法相似：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script <span class="keyword">async</span> src=<span class="string">"script.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"script.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>如果你同时指定了<code>async</code>和<code>defer</code>, <code>async</code>在现代浏览器中将会优先，然而那些只支持<code>defer</code>不支持<code>async</code>的老式浏览器将会使用<code>defer</code>。</p><blockquote><p>通过caniuse.com可以检测浏览器是否支持<code>async</code> <a href="https://caniuse.com/#feat=script-async" target="_blank" rel="noopener">https://caniuse.com/#feat=script-async</a> 和 <code>defer</code> <a href="https://caniuse.com/#feat=script-defer。" target="_blank" rel="noopener">https://caniuse.com/#feat=script-defer。</a></p></blockquote><p>这两属性仅仅在把<code>script</code>放在页面的<code>head</code>中才会起作用，如果放在我们前面所说的<code>body</code>标签底部是没用的。</p><h2 id="表现对比"><a href="#表现对比" class="headerlink" title="表现对比"></a>表现对比</h2><h3 id="不用defer或者async，放在head中"><a href="#不用defer或者async，放在head中" class="headerlink" title="不用defer或者async，放在head中"></a>不用defer或者async，放在head中</h3><p>下面是没有<code>defer</code>和<code>async</code>，并把script放在页面<code>head</code>里script的加载情况。</p><p><img src="/2019/03/04/通过defer和async高效加载JavaScript/without-defer-async-head.png" alt="without-defer-async-head"></p><p>解析过程在script被下载和执行完成之前是处于暂停状态的。一旦script的下载和执行完成，解析过程才会恢复。</p><h3 id="不用defer或者async，放在body中"><a href="#不用defer或者async，放在body中" class="headerlink" title="不用defer或者async，放在body中"></a>不用defer或者async，放在body中</h3><p>下面是没有<code>defer</code>和<code>async</code>，并把script放在页面<code>body</code>里, 在闭合标签之前script的加载情况。</p><p><img src="/2019/03/04/通过defer和async高效加载JavaScript/without-defer-async-body.png" alt="without-defer-async-body"></p><p>解析过程的完成没有任何暂停，直到解析完成后，script完成获取和执行。解析过程甚至是在script被下载完之前完成，所以与上一个例子相比页面会更早的呈现给用户。</p><h3 id="使用asyn，放在head中"><a href="#使用asyn，放在head中" class="headerlink" title="使用asyn，放在head中"></a>使用asyn，放在head中</h3><p>下面是使用<code>async</code>，并把script放在页面<code>head</code>标签里script的加载情况。</p><p><img src="/2019/03/04/通过defer和async高效加载JavaScript/with-async.png" alt="with-async"></p><p>script通过异步的方式获取，当完成下载后HTML解析将被暂停并去执行这个script，然后HTML恢复解析。</p><h3 id="使用defer，放在head中"><a href="#使用defer，放在head中" class="headerlink" title="使用defer，放在head中"></a>使用defer，放在head中</h3><p>下面是使用<code>async</code>，并把script放在页面<code>head</code>标签里script的加载情况。</p><p><img src="/2019/03/04/通过defer和async高效加载JavaScript/with-defer.png" alt="with-defer"></p><p>script脚本通过异步的方式获取，它只会在HTML解析完成之后执行。</p><p>解析完成的过程就像当我们把script放在<code>body</code>标签的结尾处一样。但是总的来说，script的执行结束要比前者好，因为script的下载是与HTML解析并行的。</p><p>所以在提速的术语中,这是胜出方案。🏆</p><h3 id="阻塞解析"><a href="#阻塞解析" class="headerlink" title="阻塞解析"></a>阻塞解析</h3><p><code>async</code>会阻塞页面的解析，而<code>defer</code>不会。</p><h3 id="阻塞渲染"><a href="#阻塞渲染" class="headerlink" title="阻塞渲染"></a>阻塞渲染</h3><p><code>async</code>和<code>defer</code>对于阻塞渲染都不能做任何保证，这取决于你和你的script脚本(例如，确保你的那些script脚本在<code>onLoad</code>事件之后才运行)</p><h3 id="domInteractive"><a href="#domInteractive" class="headerlink" title="domInteractive"></a>domInteractive</h3><p>被标记位<code>defer</code>的脚本在<code>domInteractive</code>事件后都能被正确的执行，<code>domInteractive</code>事件发生在HTML加载、解析完成、<code>DOM</code>已经被创建后。</p><p>CSS和图片在这个时候仍然处于被解析和加载的路上。</p><p>一旦上述过程完成，浏览器将会触发<code>domComplete</code>事件，然后触发<code>onLoad</code>事件。</p><p><code>domInteractive</code>是十分重要的，因为它的时间测定可以被用来衡量人所感知的加载速度。<a href="https://developer.mozilla.org/en-US/docs/Web/API/PerformanceTiming/domInteractive" target="_blank" rel="noopener">查看MDN</a>获取更多信息。</p><h3 id="保持有序"><a href="#保持有序" class="headerlink" title="保持有序"></a>保持有序</h3><p>另一个支持使用<code>defer</code>的场景：多个被标记为<code>async</code>的script脚本是在他们可用的时候以随意的顺序执行。多个被标记位<code>defer</code>的script脚本是按它们在html中定义的顺序执行（在HTML解析完成以后）。</p><h3 id="直接告诉我最好的方式就好了"><a href="#直接告诉我最好的方式就好了" class="headerlink" title="直接告诉我最好的方式就好了"></a>直接告诉我最好的方式就好了</h3><p>当用到<code>script</code>时，最好的提升你的页面加载速度的方式是把<code>script</code>放在<code>head</code>标签中，然后给<code>script</code>标签添加上<code>defer</code>属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script defer src=<span class="string">"script.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>这是更快触发<code>domInteractive</code>事件的方案。</p><p>考虑那些推荐使用<code>defer</code>情况，似乎在大多数场景下<code>defer</code>比<code>async</code>是个更好的选择。</p><p>如果你不在意页面第一次渲染的延时，确保你的JavaScript在页面已经被解析前已经被执行了。</p><hr><p>END</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;文本是&lt;a href=&quot;https://flaviocopes.com/javascript-async-defer/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Efficiently load JavaScript with defer and async&lt;/a&gt;的译文,以下为译文正文部分。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;通过defer和async高效加载JavaScript&quot;&gt;&lt;a href=&quot;#通过defer和async高效加载JavaScript&quot; class=&quot;headerlink&quot; title=&quot;通过defer和async高效加载JavaScript&quot;&gt;&lt;/a&gt;通过defer和async高效加载JavaScript&lt;/h1&gt;&lt;p&gt;当在一个HTML页面上加载一个script时，你需要小心应对以免引起页面的加载性能问题。&lt;/p&gt;
&lt;p&gt;一个script传统上通过下面这种方式引入：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;script src=&lt;span class=&quot;string&quot;&gt;&quot;script.js&quot;&lt;/span&gt;&amp;gt;&lt;span class=&quot;xml&quot;&gt;&lt;span class=&quot;tag&quot;&gt;&amp;lt;/&lt;span class=&quot;name&quot;&gt;script&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当HTML解析器发现这行代码时，一个请求将被准备好去获取这个script并执行这个script.&lt;/p&gt;
    
    </summary>
    
      <category term="翻译" scheme="http://fanlion.cc/categories/%E7%BF%BB%E8%AF%91/"/>
    
    
      <category term="JavaScript" scheme="http://fanlion.cc/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>聊聊前端的双飞翼布局和圣杯布局</title>
    <link href="http://fanlion.cc/2018/03/17/%E8%81%8A%E8%81%8A%E5%89%8D%E7%AB%AF%E7%9A%84%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80%E5%92%8C%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80/"/>
    <id>http://fanlion.cc/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/</id>
    <published>2018-03-17T14:41:17.000Z</published>
    <updated>2019-03-04T13:07:33.127Z</updated>
    
    <content type="html"><![CDATA[<p>应工作的安排混迹前端圈也有一段时间了，经历了从后端转前端并接手的第一个项目就是React的痛苦转变后，也有了良好的思想觉悟了。不是一家人不入一家门，混圈入门就从有趣的CSS开始吧。今天也遇到了大名鼎鼎的“双飞翼布局”和“圣杯布局”两种布局方式，毕竟闻名不如一见，动手实践是最好的老师，那就边写边做个记录吧。至于概念….,就算了。只要知道的就是两种布局方式都是为了实现三栏布局，中间部分宽度自适应，两边的侧边栏固定宽度就行了。</p><hr><h1 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h1><p>其实按时间来讲的话是先有圣杯布局的，双飞翼布局是由淘宝后来提出的布局方式，其命名就是依据其直观上的展示命名的 - - - 两个翅膀。双飞翼布局的代码少一些，那就从它开始吧。</p><a id="more"></a><p>不说废话，先上文档结构！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span>中间栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>双飞翼布局的文档结构有个特点就是三栏布局的中间栏写在前面的，这样浏览器渲染可以先渲染前面的这部分内容，毕竟现实中大部分情况下中间的内容才是主要的显示区。下面一步步的实现这个布局过程。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img1.png" alt="双飞翼布局步骤1"></p><p>三个元素都设置成了<code>float:left</code>,但是中间栏的外包裹<code>wrap</code>元素设置了宽度为100%(这里是相对body元素的大小),所以导致了<code>left</code>和<code>right</code>元素都被挤了下去，也就是挤到了第二行。下面我们一步一步的让左、右栏元素跑到第一行来。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 新增的代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img2.png" alt="双飞翼布局步骤2"></p><p>可以看到在给<code>left</code>元素设置<code>margin-left: -100%</code>后，由于负外边距的原因后左边栏跑到了第一行的最左边。这里的100%值与<code>wrap</code>的宽度值是相等的。同时因为<code>left</code>跑到第一行去以后，<code>right</code>也乘机往左边挪动了下，占据了原来<code>left</code>的位置。也可以看到有先见之明的给<code>middle</code>元素的左外边距设置了300px的大小，这个大小刚好等于<code>left</code>的宽度，避免中间栏中的内容被覆盖掉，同理<code>middle</code>的右外边距也是这个作用。</p><p>浮动元素之间是一个挨着一个的，设置负外边距会覆盖前一个浮动元素，实在不理解可以考虑在一行中浮动三个元素，自己体验下。好了，下面应该大家都知道了就是让<code>right</code>也跑到第一行去了。</p><p>再上代码，让<code>right</code>也跑上去。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: gray;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 新增的代码, 为自身宽度 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着上图,大功告成，鼓掌~。</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img3.png" alt="双飞翼布局步骤3"></p><h2 id="双飞翼布局总结"><a href="#双飞翼布局总结" class="headerlink" title="双飞翼布局总结"></a>双飞翼布局总结</h2><p>双飞翼布局是一种中间栏自适应、两个侧边栏固定的三栏布局方式，是利用浮动元素负外边距实现的布局效果。具有中间栏的文档位置位于两侧边栏前面，浏览器自上而下优先渲染中间栏。同时也存在着中间栏需要一个多余的外包裹元素的“缺点”。</p><h1 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h1><p>聊完了双飞翼布局后是时候聊聊它的前辈“圣杯布局”了，先上文档结构。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrap"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"middle"</span>&gt;</span>中间栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span>左边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span>右边栏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从文档结构上看，圣杯布局的结构和双飞翼布局的结构差不多，只是三栏元素都被一个外包裹层包裹（本文中的双飞翼布局的外包裹层为<code>body</code>,这里可以看做是双飞翼布局是移除了<code>middle</code>的外包裹层）。</p><p>下面让我们一起看看圣杯布局的CSS部分。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img4.png" alt="圣杯布局步骤1"></p><p>从上面的CSS和效果图中可以看出，圣杯布局也是让三栏<code>float: left</code>的方式，同时为了让<code>middle</code>宽度自适应我们让<code>middle</code>的宽度为100%，并把<code>left</code>和<code>right</code>挤了下去。为了让侧边两栏跑到第一行中，我们按照双飞翼布局的思路对<code>left</code>和<code>right</code>采用负<code>margin-left</code>的方式进行移动。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>; <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>; <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img5.png" alt="圣杯布局步骤2"></p><p>不出所料，侧边栏<code>left</code>和<code>right</code>按预期跑到了相应的位置，但是我们同时发现了<code>middle</code>中的左右部分被遮盖了住了（<code>middle</code>中的文字不见了）。因为多个浮动元素在一行中因为父外边距导致遮盖时，后面的元素会覆盖前面的元素。所以下面我们想办法让<code>middle</code>的两侧挪出位置，给两侧边栏让路。此时，<code>middle</code>已经设置<code>width: 100%</code>了。如果还要设置<code>middle</code>的左右外边距来空出位置是无法实现的。所以我们只能考虑从三个元素的父元素的<code>wrap</code>的padding值来实现了。</p><p>下面给<code>.wrap</code>元素添加上左右<code>padding</code>值，左右<code>padding</code>值分别等于左右边侧栏所需要的宽度。看下面代码，只新增了一行。<strong>至始至终为了减少不必要的代码，我们没有给<code>wrap</code>元素设置清除浮动相关的代码，这里的<code>wrap</code>是坍塌的。平时应该根据自己的情况清除浮动</strong>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">300px</span>; <span class="comment">/* 新增代码 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上效果图</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img6.png" alt="圣杯布局步骤3"></p><p>经过层层努力，终于快看到曙光了，我们已经在<code>middle</code>的两边留出了空白了，但是还不是我们想要的。如果能够让<code>left</code>和<code>right</code>能够移动到<code>wrap</code>相应的内边距位置就好了，所以此时我们采用<strong>相对定位</strong>的方式，让<code>left</code>和<code>right</code>移动到两边去。看代码：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrap</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">200px</span> <span class="number">0</span> <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">background</span>: crimson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: yellow;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="comment">/* 新增代码 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">200px</span>;</span><br><span class="line">  <span class="attribute">background</span>: green;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">200px</span>;</span><br><span class="line">  <span class="comment">/* 新增代码 */</span></span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">right</span>: -<span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上效果图</p><p><img src="/2018/03/17/聊聊前端的双飞翼布局和圣杯布局/img7.png" alt="圣杯布局步骤4"></p><p>看图说话，大功告成~</p><h2 id="圣杯布局总结"><a href="#圣杯布局总结" class="headerlink" title="圣杯布局总结"></a>圣杯布局总结</h2><p>圣杯布局和双飞翼布局类似，都是采用三栏浮动，中间栏宽度100%,并通过设置侧边栏负外边距来让三栏放在一行上。圣杯布局与双飞翼布局中的一个不同点就是在如何给两侧边栏预留位置上采用了不同思路。圣杯布局是先用父元素<code>wrap</code>的<code>padding</code>预留位置再采用相对定位来挪动位置，而双飞翼布局因为<code>middle</code>元素多了个外包裹元素，<code>middle</code>元素直接采用左右margin就实现了圣杯布局的效果。</p><h1 id="最后几句"><a href="#最后几句" class="headerlink" title="最后几句"></a>最后几句</h1><p>动手实践才是最好的老师，一步步的实践会让你真正的了解一个东西，只看不实践永远都是顺着别人的思路在学习。与君共勉~</p><p>本文原始地址：<a href="https://fanlion.cc/2018/03/17/聊聊前端的双飞翼布局和圣杯布局">https://fanlion.cc/2018/03/17/聊聊前端的双飞翼布局和圣杯布局</a></p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://www.cnblogs.com/2050/archive/2012/08/13/2636467.html" target="_blank" rel="noopener">CSS布局奇淫巧计之-强大的负边距</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;应工作的安排混迹前端圈也有一段时间了，经历了从后端转前端并接手的第一个项目就是React的痛苦转变后，也有了良好的思想觉悟了。不是一家人不入一家门，混圈入门就从有趣的CSS开始吧。今天也遇到了大名鼎鼎的“双飞翼布局”和“圣杯布局”两种布局方式，毕竟闻名不如一见，动手实践是最好的老师，那就边写边做个记录吧。至于概念….,就算了。只要知道的就是两种布局方式都是为了实现三栏布局，中间部分宽度自适应，两边的侧边栏固定宽度就行了。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;双飞翼布局&quot;&gt;&lt;a href=&quot;#双飞翼布局&quot; class=&quot;headerlink&quot; title=&quot;双飞翼布局&quot;&gt;&lt;/a&gt;双飞翼布局&lt;/h1&gt;&lt;p&gt;其实按时间来讲的话是先有圣杯布局的，双飞翼布局是由淘宝后来提出的布局方式，其命名就是依据其直观上的展示命名的 - - - 两个翅膀。双飞翼布局的代码少一些，那就从它开始吧。&lt;/p&gt;
    
    </summary>
    
      <category term="前端" scheme="http://fanlion.cc/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="CSS" scheme="http://fanlion.cc/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>博客说明</title>
    <link href="http://fanlion.cc/2018/03/16/%E5%8D%9A%E5%AE%A2%E8%AF%B4%E6%98%8E/"/>
    <id>http://fanlion.cc/2018/03/16/博客说明/</id>
    <published>2018-03-16T13:05:50.000Z</published>
    <updated>2019-03-04T13:07:33.127Z</updated>
    
    <content type="html"><![CDATA[<p>在那还是纸张传播信息的年代，我每次换了一本新的日记本的时候都会在扉页上写下关于这本笔记本的来历以及自己的近期的状况，用以做序。不例外，本篇文字片段作为博客的第一篇文章也会记录下博客的来历以及近期个人的一些状况，以做留恋。</p><hr><h1 id="我的博客历程"><a href="#我的博客历程" class="headerlink" title="我的博客历程"></a>我的博客历程</h1><a id="more"></a><p>我的第一个个人博客可以从2016年的夏天开始说起。至今任然记得在那个炎热的暑假，整个学院的学生都留在了学校进行计算机课程实践（做个XXX管理系统）,陕西的夏天异常炎热，达到了出门鞋底都在”瑟瑟发抖”的地步。就是在这样一个炎热的夏天，出于对计算机的热爱，自己利用了课余时间开始写了我的第一个个人博客系统。由于专业所学的是Java体系，所以博客最终以Spring框架开始，像搭积木一样的按自己的想象搭建了起来并部署在了阿里云上。部署成功后情不自禁的到处向同学嘚瑟（其实当时还是蛮有成就感的），回想起来这也是我正式猿届工作的一个热身运动吧。可是好景不长，后面由于找工作的缘故加上阿里云高昂的费用（70RMB）博客仅在2月内就被云服务商给”垃圾“回收了。</p><p>后面我也随着毕业的大潮奔赴了工作岗位,成为了奋斗一线的小猿，由于上班的第一年事情也不是很多,头发还是算茂盛精力也还算旺盛,于是又考虑起了恢复博客的计划。吃第二口后的食物比不上咬第一口的时候给人的满足感强烈，加上看过几天Python所以考虑博客采用Python搭建，既然Java实现过了就不在实现了。一小段时间过去后一个新的博客系统又出来了 <a href="http://www.vanblog.cn/" target="_blank" rel="noopener">VanBlog</a>。新博客出来后也没正儿八经的写过几篇文章，好不容易产出的几篇流水账文章又经历了服务器被墙、Docker异常后数据丢失。最终考虑到自建博客系统所需要的运维成本以及不稳定的因素后开始考虑了弃坑。VanBlog也就最终画上了自建博客的句号。目前仅作为Demo展示，<a href="https://github.com/fanlion/dream_blog" target="_blank" rel="noopener">博客源码</a>。</p><p>经历过数据丢失后，最终选择了Hexo搭建个人博客的方式，并以个人常用昵称作为域名<a href="https://fanlion.cc/">fanlion</a></p><h1 id="为什么想写博客"><a href="#为什么想写博客" class="headerlink" title="为什么想写博客"></a>为什么想写博客</h1><p>这里应该是为什么想写点技术相关的博客了。工作已经差不多两年了，在这期间出于对技术的热情也看过不少的书籍和网文，零零散散的知识片段散落在各个角落，并不成体系。日常的学习方式倾向于阅读，导致很多知识点过目就忘，未曾深究。回头一想，知识成体系的一个方法就是总结，当把碰到的知识点用自己的语言组织起来的时候就会产生知识体系。毕竟，在写好一篇技术文章时和自己零散的学习过程是不一样的，写文章时会涉及到深加工和传播的过程。所以痛定思痛，也尝试着把自己接触过的东西总结出来写成一篇博客。</p><p>一直认为有思想并能把思想表达出来是一件很难得的事。与君共勉!</p><p>联系我：<a href="mailto:fan.lion@foxmail.com" target="_blank" rel="noopener">fan.lion@foxmail.com</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在那还是纸张传播信息的年代，我每次换了一本新的日记本的时候都会在扉页上写下关于这本笔记本的来历以及自己的近期的状况，用以做序。不例外，本篇文字片段作为博客的第一篇文章也会记录下博客的来历以及近期个人的一些状况，以做留恋。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;我的博客历程&quot;&gt;&lt;a href=&quot;#我的博客历程&quot; class=&quot;headerlink&quot; title=&quot;我的博客历程&quot;&gt;&lt;/a&gt;我的博客历程&lt;/h1&gt;
    
    </summary>
    
    
      <category term="公告" scheme="http://fanlion.cc/tags/%E5%85%AC%E5%91%8A/"/>
    
  </entry>
  
</feed>
